{"version":3,"sources":["images/loader.svg","images/close-icon.svg","Gif.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","Gif","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","loaded","_this2","images","react_default","a","createElement","className","concat","autoPlay","loop","src","original","mp4","onLoadedData","setState","Component","Header","_ref","clearSearch","hasResults","onClick","clearButton","randomChoice","arr","Math","floor","random","length","UserHint","_ref2","loading","hintText","loader","App","searchGiphy","_ref3","asyncToGenerator","regenerator_default","mark","_callee","searchTerm","response","_ref4","data","randomGif","wrap","_context","prev","next","fetch","sent","json","console","log","prevState","objectSpread","gif","gifs","toConsumableArray","t0","stop","_x","apply","arguments","handleChange","event","value","target","handleKeyPress","key","textInput","focus","_this$state","App_Header","map","src_Gif","onChange","placeholder","onKeyPress","ref","input","App_UserHint","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"4EAAAA,EAAAC,QAAiBC,EAAAC,EAAuB,uDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,+QC8BzBC,cAxBb,SAAAA,EAAYC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACjBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KACDQ,MAAQ,CACXC,QAAQ,GAHOR,wEAOV,IAAAS,EAAAN,KACCK,EAAWL,KAAKI,MAAhBC,OACAE,EAAWP,KAAKJ,MAAhBW,OACR,OACEC,EAAAC,EAAAC,cAAA,SAEEC,UAAS,mBAAAC,OAAqBP,GAAU,UACxCQ,UAAQ,EACRC,MAAI,EACJC,IAAKR,EAAOS,SAASC,IAErBC,aAAc,kBAAMZ,EAAKa,SAAS,CAAEd,QAAQ,cArBlCe,8BCYZC,EAAS,SAAAC,GAAA,IAAGC,EAAHD,EAAGC,YAAaC,EAAhBF,EAAgBE,WAAhB,OACbhB,EAAAC,EAAAC,cAAA,OAAKC,UAAU,eAEZa,EACChB,EAAAC,EAAAC,cAAA,UAAQe,QAASF,GACff,EAAAC,EAAAC,cAAA,OAAKK,IAAKW,OAGZlB,EAAAC,EAAAC,cAAA,MAAIC,UAAU,SAAd,gBAMAgB,EAAe,SAAAC,GAEnB,OAAOA,EADWC,KAAKC,MAAMD,KAAKE,SAAWH,EAAII,UAI7CC,EAAW,SAAAC,GAAA,IAAGC,EAAHD,EAAGC,QAASC,EAAZF,EAAYE,SAAZ,OACf5B,EAAAC,EAAAC,cAAA,OAAKC,UAAU,aACZwB,EAAU3B,EAAAC,EAAAC,cAAA,OAAKK,IAAKsB,IAAQ1B,UAAU,kBAAqByB,IAmJjDE,cA9Ib,SAAAA,EAAY1C,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAsC,IACjBzC,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAwC,GAAAnC,KAAAH,KAAMJ,KAYR2C,YAbmB,eAAAC,EAAA1C,OAAA2C,EAAA,EAAA3C,CAAA4C,EAAAjC,EAAAkC,KAaL,SAAAC,EAAMC,GAAN,IAAAC,EAAAC,EAAAC,EAAAC,EAAA,OAAAP,EAAAjC,EAAAyC,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cAEZxD,EAAKO,MAAQ,CACX+B,SAAS,GAHCgB,EAAAC,KAAA,EAAAD,EAAAE,KAAA,EAOaC,MAAK,mFAAA1C,OACyDiC,EADzD,wCAPlB,cAOJC,EAPIK,EAAAI,KAAAJ,EAAAE,KAAA,EAWaP,EAASU,OAXtB,UAAAT,EAAAI,EAAAI,MAWFP,EAXED,EAWFC,MAGEhB,OAdA,CAAAmB,EAAAE,KAAA,wCAAAzC,OAewBiC,GAfxB,QAmBJI,EAAYtB,EAAaqB,GAE/BS,QAAQC,IAAIT,GACZQ,QAAQC,IAAIV,EAAKA,MAEjBnD,EAAKsB,SAAS,SAACwC,EAAW/D,GAAZ,OAAAE,OAAA8D,EAAA,EAAA9D,CAAA,GACT6D,EADS,CAGZE,IAAKZ,EAELa,KAAKhE,OAAAiE,EAAA,EAAAjE,CAAK6D,EAAUG,MAAhBlD,OAAA,CAAsBqC,IAE1Bd,SAAS,EACTC,SAAQ,iCAAAxB,OAAmCiC,OAhCnCM,EAAAE,KAAA,iBAAAF,EAAAC,KAAA,GAAAD,EAAAa,GAAAb,EAAA,SAmCVtD,EAAKsB,SAAS,SAACwC,EAAW/D,GAAZ,MAAuB,CACnCwC,SAAQe,EAAAa,GACR7B,SAAS,KAEXsB,QAAQC,IAARP,EAAAa,IAvCU,yBAAAb,EAAAc,SAAArB,EAAA5C,KAAA,aAbK,gBAAAkE,GAAA,OAAA1B,EAAA2B,MAAAnE,KAAAoE,YAAA,GAAAvE,EA0DnBwE,aAAe,SAAAC,GAAS,IAEdC,EAAUD,EAAME,OAAhBD,MACRd,QAAQC,IAAIa,GACZ1E,EAAKsB,SAAS,SAACwC,EAAW/D,GAAZ,OAAAE,OAAA8D,EAAA,EAAA9D,CAAA,GAET6D,EAFS,CAIZd,WAAY0B,EAEZnC,SAAUmC,EAAMvC,OAAS,EAAf,uBAAApB,OAA0C2D,GAAU,QAE5DA,EAAMvC,OAAS,GACjByB,QAAQC,IAAI,gCAvEG7D,EA2EnB4E,eAAiB,SAAAH,GAEfb,QAAQC,IAAIY,EAAMI,KAFM,IAIhBH,EAAUD,EAAME,OAAhBD,MAEJA,EAAMvC,OAAS,GAAmB,UAAdsC,EAAMI,KAC5B7E,EAAK0C,YAAYgC,IAlFF1E,EAuFnB0B,YAAc,WACZ1B,EAAKsB,SAAS,SAACwC,EAAW/D,GAAZ,OAAAE,OAAA8D,EAAA,EAAA9D,CAAA,GACT6D,EADS,CAEZd,WAAY,GACZT,SAAU,GACV0B,KAAM,OAGRjE,EAAK8E,UAAUC,SA7Ff/E,EAAKO,MAAQ,CACX+B,SAAS,EACTU,WAAY,IACZT,SAAU,sCACVyB,IAAK,KAELC,KAAM,IARSjE,wEAkGV,IAAAS,EAAAN,KAAA6E,EAE2B7E,KAAKI,MAA/ByC,EAFDgC,EAEChC,WAEFrB,GAJCqD,EAEahB,IAFbgB,EAEkBf,KAED9B,QAExB,OACExB,EAAAC,EAAAC,cAAA,OAAKC,UAAU,QACbH,EAAAC,EAAAC,cAACoE,EAAD,CAAQvD,YAAavB,KAAKuB,YAAaC,WAAYA,IAEnDhB,EAAAC,EAAAC,cAAA,MAAIe,QAASzB,KAAKuB,aAAlB,gBACAf,EAAAC,EAAAC,cAAA,OAAKC,UAAU,eAYZX,KAAKI,MAAM0D,KAAKiB,IAAI,SAAAlB,GAAG,OAAIrD,EAAAC,EAAAC,cAACsE,EAAQnB,KAGrCrD,EAAAC,EAAAC,cAAA,SACEuE,SAAUjF,KAAKqE,aACf1D,UAAU,kBACVuE,YAAY,iBACZC,WAAYnF,KAAKyE,eACjBF,MAAO1B,EACPuC,IAAK,SAAAC,GACH/E,EAAKqE,UAAYU,MAKvB7E,EAAAC,EAAAC,cAAC4E,EAAatF,KAAKI,eAzITgB,aC9BEmE,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCVNC,IAASC,OAAOrF,EAAAC,EAAAC,cAACoF,EAAD,MAASC,SAASC,eAAe,SDmH3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.144f5ba3.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/loader.be00fc4a.svg\";","module.exports = __webpack_public_path__ + \"static/media/close-icon.5b9a3ae1.svg\";","import App from \"./App\";\nimport React, { Component } from \"react\";\n\nclass Gif extends Component {\n  // when our vid has loaded, we add loaded class name\n  //otherwise the vid stays hidden\n  constructor(props) {\n    super(props);\n    this.state = {\n      loaded: false\n    };\n  }\n\n  render() {\n    const { loaded } = this.state;\n    const { images } = this.props;\n    return (\n      <video\n        //when we have the loaded state as true, we add a loaded class\n        className={`grid-item video ${loaded && \"loaded\"}`}\n        autoPlay\n        loop\n        src={images.original.mp4}\n        // when the vid leads, we set the loaded state to be true\n        onLoadedData={() => this.setState({ loaded: true })}\n      />\n    );\n  }\n}\n\nexport default Gif;\n","import React, { Component } from \"react\";\n// we imported our loader spinner as image, used down below\nimport loader from \"./images/loader.svg\";\nimport Gif from \"./Gif\";\nimport clearButton from \"./images/close-icon.svg\";\n\n/*\nconst getData = async searchTerm => {\n  try {\n  } catch (error) {\n    alert(error);\n  }\n};\n*/\n\nconst Header = ({ clearSearch, hasResults }) => (\n  <div className=\"header grid\">\n    {/*if we have results, show clear button. otherwise, show the title at top! */}\n    {hasResults ? (\n      <button onClick={clearSearch}>\n        <img src={clearButton} />\n      </button>\n    ) : (\n      <h1 className=\"title\"> Giphy App</h1>\n    )}\n  </div>\n);\n\n//random gif function\nconst randomChoice = arr => {\n  const randIndex = Math.floor(Math.random() * arr.length);\n  return arr[randIndex];\n};\n\nconst UserHint = ({ loading, hintText }) => (\n  <div className=\"user-hint\">\n    {loading ? <img src={loader} className=\"block mx-auto\" /> : hintText}\n  </div>\n);\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      loading: false,\n      searchTerm: \" \",\n      hintText: \"Type above. Hit Enter key to search\",\n      gif: null,\n      //  where we store of gifs\n      gifs: []\n    };\n  }\n  //we can also write ASYNC methods into our components\n  //that let us use the ASYNC/AWAIT style of funcs.\n  searchGiphy = async searchTerm => {\n    //here we set the loading state to be true and this will show spinner at the btm\n    this.state = {\n      loading: true\n    };\n\n    try {\n      const response = await fetch(\n        `https://api.giphy.com/v1/gifs/search?api_key=N02XfqFWTaorgl6T6d3s0QII3nE89YDF&q=${searchTerm}&limit=25&offset=0&rating=G&lang=en`\n      );\n      //here we convert our raw response into json data\n      const { data } = await response.json();\n\n      // check if array of results is empty? if so, throw error that'll stop the code here and handle it in the catch area\n      if (!data.length) {\n        throw `nothing found here for ${searchTerm}`;\n      }\n\n      // here we grab a random result from our imgs\n      const randomGif = randomChoice(data);\n\n      console.log(randomGif);\n      console.log(data.data);\n\n      this.setState((prevState, props) => ({\n        ...prevState,\n        // rather than getting 1st result (data[0]) we want randoms\n        gif: randomGif,\n        //take our prev gifs and spread them out, then add our latest new gif in there\n        gifs: [...prevState.gifs, randomGif],\n        // we turn off the loading spinner again\n        loading: false,\n        hintText: `You can hit enter to see more ${searchTerm}`\n      }));\n    } catch (error) {\n      this.setState((prevState, props) => ({\n        hintText: error,\n        loading: false\n      }));\n      console.log(error);\n    }\n  };\n\n  // with create-react-app we can write our methods as arrow functions\n  // meaning we don't need CONSTRUCTOR and BIND\n  handleChange = event => {\n    // const value = event.target.value\n    const { value } = event.target;\n    console.log(value);\n    this.setState((prevState, props) => ({\n      // we take our old props and spread them out here\n      ...prevState,\n      // and then overwrite them with the ones we want\n      searchTerm: value,\n      // we set the hint text only when we have more than 2 characters, otherwise it'll just me a blank string\n      hintText: value.length > 2 ? `HIT ENTER TO SEARCH ${value}` : \" \"\n    }));\n    if (value.length > 2) {\n      console.log(\"this is a valid search term\");\n    }\n  };\n\n  handleKeyPress = event => {\n    // to see value of key pressed\n    console.log(event.key);\n\n    const { value } = event.target;\n\n    if (value.length > 2 && event.key === \"Enter\") {\n      this.searchGiphy(value);\n    }\n  };\n\n  // Function to CLEAR search by RESETTING the state...\n  clearSearch = () => {\n    this.setState((prevState, props) => ({\n      ...prevState,\n      searchTerm: \"\",\n      hintText: \"\",\n      gifs: []\n    }));\n    // here we grab the input THEN focus the cursor back into it (USING REFS)\n    this.textInput.focus();\n  };\n\n  render() {\n    // const searchTerm = this.state.searchTerm\n    const { searchTerm, gif, gifs } = this.state;\n    // here we set a var to see is we have any results\n    const hasResults = gifs.length;\n\n    return (\n      <div className=\"page\">\n        <Header clearSearch={this.clearSearch} hasResults={hasResults} />\n\n        <h1 onClick={this.clearSearch}>Clear Search</h1>\n        <div className=\"search grid\">\n          {/*to get 1 video to show, but we will do several videos below\n          {gif && (\n            <video\n              className=\"grid-item video\"\n              autoPlay\n              loop\n              src={gif.images.original.mp4}\n            />\n          )}*/}\n\n          {/*CREATING/LAYERING LOTS OF VIDEOS, we loop over our arr of gifs from state*/}\n          {this.state.gifs.map(gif => <Gif {...gif} />)}\n\n          {/*our stack of images*/}\n          <input\n            onChange={this.handleChange}\n            className=\"input grid-item\"\n            placeholder=\"type something\"\n            onKeyPress={this.handleKeyPress}\n            value={searchTerm}\n            ref={input => {\n              this.textInput = input;\n            }}\n          />\n        </div>\n        {/*here we pass our UserHint all of our state using a spread*/}\n        <UserHint {...this.state} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n\n              // Execute callback\n              if (config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./css/main.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}